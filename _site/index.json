{
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | CoverageKiller2",
    "keywords": "Getting Started"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | CoverageKiller2",
    "keywords": "Introduction"
  },
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE. | CoverageKiller2",
    "keywords": "This is the HOMEPAGE. Refer to Markdown for how to write markdown files. Quick Start Notes: Add images to the images folder if the file is referencing an image."
  },
  "packages/Serilog.4.0.2/README.html": {
    "href": "packages/Serilog.4.0.2/README.html",
    "title": "Serilog | CoverageKiller2",
    "keywords": "Serilog Serilog is a diagnostic logging library for .NET applications. It is easy to set up, has a clean API, and runs on all recent .NET platforms. While it's useful even in the simplest applications, Serilog's support for structured logging shines when instrumenting complex, distributed, and asynchronous applications and systems. Like many other libraries for .NET, Serilog provides diagnostic logging to files, the console, and many other outputs. using var log = new LoggerConfiguration() .WriteTo.Console() .WriteTo.File(\"log.txt\") .CreateLogger(); log.Information(\"Hello, Serilog!\"); Unlike other logging libraries, Serilog is built from the ground up to record structured event data. var position = new { Latitude = 25, Longitude = 134 }; var elapsedMs = 34; log.Information(\"Processed {@Position} in {Elapsed} ms\", position, elapsedMs); Serilog uses message templates, a simple DSL that extends .NET format strings with named as well as positional parameters. Instead of formatting events immediately into text, Serilog captures the values associated with each named parameter. The example above records two properties, Position and Elapsed, in the log event. The @ operator in front of Position tells Serilog to serialize the object passed in, rather than convert it using ToString(). Serilog's deep and rich support for structured event data opens up a huge range of diagnostic possibilities not available when using traditional loggers. Rendered into JSON format for example, these properties appear alongside the timestamp, level, and message like: {\"Position\": {\"Latitude\": 25, \"Longitude\": 134}, \"Elapsed\": 34} Back-ends that are capable of recording structured event data make log searches and analysis possible without log parsing or regular expressions. Supporting structured data doesn't mean giving up text: when Serilog writes events to files or the console, the template and properties are rendered into friendly human-readable text just like a traditional logging library would produce: 09:14:22 [INF] Processed {\"Latitude\": 25, \"Longitude\": 134} in 34 ms. Upgrading from an earlier Serilog version? Find release notes here. Features Community-backed and actively developed Format-based logging API with familiar levels like Debug, Information, Warning, Error, and so-on Discoverable C# configuration syntax and optional XML or JSON configuration support Efficient when enabled, extremely low overhead when a logging level is switched off Best-in-class .NET Core support, including rich integration with ASP.NET Core Support for a comprehensive range of sinks, including files, the console, on-premises and cloud-based log servers, databases, and message queues Sophisticated enrichment of log events with contextual information, including scoped (LogContext) properties, thread and process identifiers, and domain-specific correlation ids such as HttpRequestId Zero-shared-state Logger objects, with an optional global static Log class Format-agnostic logging pipeline that can emit events in plain text, JSON, in-memory LogEvent objects (including Rx pipelines) and other formats Getting started Serilog is installed from NuGet. To view log events, one or more sinks need to be installed as well, here we'll use the pretty-printing console sink, and a rolling file set: dotnet add package Serilog dotnet add package Serilog.Sinks.Console dotnet add package Serilog.Sinks.File The simplest way to set up Serilog is using the static Log class. A LoggerConfiguration is used to create and assign the default logger, normally in Program.cs: using Serilog; Log.Logger = new LoggerConfiguration() .WriteTo.Console() .WriteTo.File(\"log.txt\", rollingInterval: RollingInterval.Day, rollOnFileSizeLimit: true) .CreateLogger(); try { // Your program here... const string name = \"Serilog\"; Log.Information(\"Hello, {Name}!\", name); throw new InvalidOperationException(\"Oops...\"); } catch (Exception ex) { Log.Error(ex, \"Unhandled exception\"); } finally { await Log.CloseAndFlushAsync(); // ensure all logs written before app exits } Find more, including a runnable example application, under the Getting Started topic in the documentation. Getting help To learn more about Serilog, check out the documentation - you'll find information there on the most common scenarios. If Serilog isn't working the way you expect, you may find the troubleshooting guide useful. Serilog has an active and helpful community who are happy to help point you in the right direction or work through any issues you might encounter. You can get in touch via: Stack Overflow — this is the best place to start if you have a question. Many track the serilog tag there. The #serilog tag on Twitter Serilog-related courses on Pluralsight We welcome reproducible bug reports and detailed feature requests through our GitHub issue tracker; note the other resource are much better for quick questions or seeking usage help. Contributing Would you like to help make Serilog even better? We keep a list of issues that are approachable for newcomers under the up-for-grabs label (accessible only when logged into GitHub). Before starting work on a pull request, we suggest commenting on, or raising, an issue on the issue tracker so that we can help and coordinate efforts. For more details check out our contributing guide. When contributing please keep in mind our Code of Conduct. Detailed build status Branch AppVeyor dev main Serilog is copyright © Serilog Contributors - Provided under the Apache License, Version 2.0. Needle and thread logo a derivative of work by Kenneth Appiah."
  },
  "packages/Serilog.Sinks.Async.2.0.0/README.html": {
    "href": "packages/Serilog.Sinks.Async.2.0.0/README.html",
    "title": "Serilog.Sinks.Async | CoverageKiller2",
    "keywords": "Serilog.Sinks.Async An asynchronous wrapper for other Serilog sinks. Use this sink to reduce the overhead of logging calls by delegating work to a background thread. This is especially suited to non-batching sinks like the File and RollingFile sinks that may be affected by I/O bottlenecks. Note: many of the network-based sinks (CouchDB, Elasticsearch, MongoDB, Seq, Splunk...) already perform asynchronous batching natively and do not benefit from this wrapper. Getting started Install from NuGet: Install-Package Serilog.Sinks.Async Assuming you have already installed the target sink, such as the file sink, move the wrapped sink's configuration within a WriteTo.Async() statement: Log.Logger = new LoggerConfiguration() .WriteTo.Async(a => a.File(\"logs/myapp.log\")) // Other logger configuration .CreateLogger() Log.Information(\"This will be written to disk on the worker thread\"); // At application shutdown (results in monitors getting StopMonitoring calls) Log.CloseAndFlush(); The wrapped sink (File in this case) will be invoked on a worker thread while your application's thread gets on with more important stuff. Because the memory buffer may contain events that have not yet been written to the target sink, it is important to call Log.CloseAndFlush() or Logger.Dispose() when the application exits. Buffering & Dropping The default memory buffer feeding the worker thread is capped to 10,000 items, after which arriving events will be dropped. To increase or decrease this limit, specify it when configuring the async sink. One can determine whether events have been dropped via Serilog.Async.IAsyncLogEventSinkInspector.DroppedMessagesCount (see Sink State Inspection interface below). // Reduce the buffer to 500 events .WriteTo.Async(a => a.File(\"logs/myapp.log\"), bufferSize: 500) Health Monitoring via the Monitor and Inspector interfaces The Async wrapper is primarily intended to allow one to achieve minimal logging latency at all times, even when writing to sinks that may momentarily block during the course of their processing (e.g., a File Sink might block for a low number of ms while flushing). The dropping behavior is an important failsafe; it avoids having an unbounded buffering behaviour should logging throughput overwhelm the sink, or the sink ingestion throughput degrade. In practice, this configuration (assuming one provisions an adequate bufferSize) achieves an efficient and resilient logging configuration that can safely handle load without impacting processing throughput. The risk is of course that events get be dropped if the buffer threshold gets breached. The inspection interface, IAsyncLogEventSinkInspector (obtained by providing an IAsyncLogEventSinkMonitor when configuring the Async Sink), enables a health monitoring mechanism to actively validate that the buffer allocation is not being exceeded in practice. // Example check: log message to an out of band alarm channel if logging is showing signs of getting overwhelmed void ExecuteAsyncBufferCheck(IAsyncLogEventSinkInspector inspector) { var usagePct = inspector.Count * 100 / inspector.BufferSize; if (usagePct > 50) SelfLog.WriteLine(\"Log buffer exceeded {0:p0} usage (limit: {1})\", usagePct, inspector.BufferSize); } class MonitorConfiguration : IAsyncLogEventSinkMonitor { public void StartMonitoring(IAsyncLogEventSinkInspector inspector) => HealthMonitor.AddPeriodicCheck(() => ExecuteAsyncBufferCheck(inspector)); public void StopMonitoring(IAsyncLogEventSinkInspector inspector) { /* reverse of StartMonitoring */ } } // Provide monitor so we can wire the health check to the inspector var monitor = new MonitorConfiguration(); // Use default config (drop events if >10,000 backlog) .WriteTo.Async(a => a.File(\"logs/myapp.log\"), monitor: monitor) ... Blocking Warning: For the same reason one typically does not want exceptions from logging to leak into the execution path, one typically does not want a logger to be able to have the side-effect of actually interrupting application processing until the log propagation has been unblocked. When the buffer size limit is reached, the default behavior is to drop any further attempted writes until the queue abates, reporting each such failure to the Serilog.Debugging.SelfLog. To replace this with a blocking behaviour, set blockWhenFull to true. // Wait for any queued event to be accepted by the `File` log before allowing the calling thread to resume its // application work after a logging call when there are 10,000 LogEvents awaiting ingestion by the pipeline .WriteTo.Async(a => a.File(\"logs/myapp.log\"), blockWhenFull: true) XML <appSettings> and JSON configuration Using Serilog.Settings.Configuration JSON: { \"Serilog\": { \"WriteTo\": [{ \"Name\": \"Async\", \"Args\": { \"configure\": [{ \"Name\": \"Console\" }] } }] } } XML configuration support has not yet been added for this wrapper. About this sink This sink was created following this conversation thread: https://github.com/serilog/serilog/issues/809."
  },
  "packages/Serilog.Sinks.Debug.3.0.0/README.html": {
    "href": "packages/Serilog.Sinks.Debug.3.0.0/README.html",
    "title": "Serilog.Sinks.Debug | CoverageKiller2",
    "keywords": "Serilog.Sinks.Debug A Serilog sink that writes log events to the Visual Studio debug output window. Getting started To use the sink, first install the NuGet package: dotnet add package Serilog.Sinks.Debug Then enable the sink using WriteTo.Debug(): Log.Logger = new LoggerConfiguration() .WriteTo.Debug() .CreateLogger(); Log.Information(\"Hello, world!\"); Log events will be printed to the debug output: XML <appSettings> configuration To use the sink with the Serilog.Settings.AppSettings package, first install that package if you haven't already done so: Install-Package Serilog.Settings.AppSettings Instead of configuring the logger in code, call ReadFrom.AppSettings(): var log = new LoggerConfiguration() .ReadFrom.AppSettings() .CreateLogger(); In your application's App.config or Web.config file, specify the console sink assembly under the <appSettings> node: <configuration> <appSettings> <add key=\"serilog:using:Debug\" value=\"Serilog.Sinks.Debug\" /> <add key=\"serilog:write-to:Debug\" /> JSON appsettings.json configuration To use the console sink with Microsoft.Extensions.Configuration, for example with ASP.NET Core or .NET Core, use the Serilog.Settings.Configuration package. First install that package if you have not already done so: Install-Package Serilog.Settings.Configuration Instead of configuring the sink directly in code, call ReadFrom.Configuration(): var configuration = new ConfigurationBuilder() .AddJsonFile(\"appsettings.json\") .Build(); var logger = new LoggerConfiguration() .ReadFrom.Configuration(configuration) .CreateLogger(); In your appsettings.json file, under the Serilog node, : { \"Serilog\": { \"WriteTo\": [\"Debug\"] } } Copyright © 2017 Serilog Contributors - Provided under the Apache License, Version 2.0."
  },
  "packages/Serilog.Sinks.File.6.0.0/README.html": {
    "href": "packages/Serilog.Sinks.File.6.0.0/README.html",
    "title": "Serilog.Sinks.File | CoverageKiller2",
    "keywords": "Serilog.Sinks.File Writes Serilog events to one or more text files. Getting started Install the Serilog.Sinks.File package from NuGet: dotnet add package Serilog.Sinks.File To configure the sink in C# code, call WriteTo.File() during logger configuration: var log = new LoggerConfiguration() .WriteTo.File(\"log.txt\", rollingInterval: RollingInterval.Day) .CreateLogger(); This will append the time period to the filename, creating a file set like: log20180631.txt log20180701.txt log20180702.txt Important: By default, only one process may write to a log file at a given time. See Shared log files below for information on multi-process sharing. Limits To avoid bringing down apps with runaway disk usage the file sink limits file size to 1GB by default. Once the limit is reached, no further events will be written until the next roll point (see also: Rolling policies below). The limit can be changed or removed using the fileSizeLimitBytes parameter. .WriteTo.File(\"log.txt\", fileSizeLimitBytes: null) For the same reason, only the most recent 31 files are retained by default (i.e. one long month). To change or remove this limit, pass the retainedFileCountLimit parameter. .WriteTo.File(\"log.txt\", rollingInterval: RollingInterval.Day, retainedFileCountLimit: null) Rolling policies To create a log file per day or other time period, specify a rollingInterval as shown in the examples above. To roll when the file reaches fileSizeLimitBytes, specify rollOnFileSizeLimit: .WriteTo.File(\"log.txt\", rollOnFileSizeLimit: true) This will create a file set like: log.txt log_001.txt log_002.txt Specifying both rollingInterval and rollOnFileSizeLimit will cause both policies to be applied, while specifying neither will result in all events being written to a single file. Old files will be cleaned up as per retainedFileCountLimit - the default is 31. XML <appSettings> configuration To use the file sink with the Serilog.Settings.AppSettings package, first install that package if you haven't already done so: Install-Package Serilog.Settings.AppSettings Instead of configuring the logger in code, call ReadFrom.AppSettings(): var log = new LoggerConfiguration() .ReadFrom.AppSettings() .CreateLogger(); In your application's App.config or Web.config file, specify the file sink assembly and required path format under the <appSettings> node: <configuration> <appSettings> <add key=\"serilog:using:File\" value=\"Serilog.Sinks.File\" /> <add key=\"serilog:write-to:File.path\" value=\"log.txt\" /> The parameters that can be set through the serilog:write-to:File keys are the method parameters accepted by the WriteTo.File() configuration method. This means, for example, that the fileSizeLimitBytes parameter can be set with: <add key=\"serilog:write-to:File.fileSizeLimitBytes\" value=\"1234567\" /> Omitting the value will set the parameter to null: <add key=\"serilog:write-to:File.fileSizeLimitBytes\" /> In XML and JSON configuration formats, environment variables can be used in setting values. This means, for instance, that the log file path can be based on TMP or APPDATA: <add key=\"serilog:write-to:File.path\" value=\"%APPDATA%\\MyApp\\log.txt\" /> JSON appsettings.json configuration To use the file sink with Microsoft.Extensions.Configuration, for example with ASP.NET Core or .NET Core, use the Serilog.Settings.Configuration package. First install that package if you have not already done so: Install-Package Serilog.Settings.Configuration Instead of configuring the file directly in code, call ReadFrom.Configuration(): var configuration = new ConfigurationBuilder() .AddJsonFile(\"appsettings.json\") .Build(); var logger = new LoggerConfiguration() .ReadFrom.Configuration(configuration) .CreateLogger(); In your appsettings.json file, under the Serilog node, : { \"Serilog\": { \"WriteTo\": [ { \"Name\": \"File\", \"Args\": { \"path\": \"log.txt\", \"rollingInterval\": \"Day\" } } ] } } See the XML <appSettings> example above for a discussion of available Args options. Controlling event formatting The file sink creates events in a fixed text format by default: 2018-07-06 09:02:17.148 +10:00 [INF] HTTP GET / responded 200 in 1994 ms The format is controlled using an output template, which the file configuration method accepts as an outputTemplate parameter. The default format above corresponds to an output template like: .WriteTo.File(\"log.txt\", outputTemplate: \"{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}\") JSON event formatting To write events to the file in an alternative format such as JSON, pass an ITextFormatter as the first argument: // Install-Package Serilog.Formatting.Compact .WriteTo.File(new CompactJsonFormatter(), \"log.txt\") Shared log files To enable multi-process shared log files, set shared to true: .WriteTo.File(\"log.txt\", shared: true) Auditing The file sink can operate as an audit file through AuditTo: .AuditTo.File(\"audit.txt\") Only a limited subset of configuration options are currently available in this mode. Performance By default, the file sink will flush each event written through it to disk. To improve write performance, specifying buffered: true will permit the underlying stream to buffer writes. The Serilog.Sinks.Async package can be used to wrap the file sink and perform all disk access on a background worker thread. Extensibility FileLifecycleHooks provide an extensibility point that allows hooking into different parts of the life cycle of a log file. You can create a hook by extending from FileLifecycleHooks and overriding the OnFileOpened and/or OnFileDeleting methods. OnFileOpened provides access to the underlying stream that log events are written to, before Serilog begins writing events. You can use this to write your own data to the stream (for example, to write a header row), or to wrap the stream in another stream (for example, to add buffering, compression or encryption) OnFileDeleting provides a means to work with obsolete rolling log files, before they are deleted by Serilog's retention mechanism - for example, to archive log files to another location Available hooks: serilog-sinks-file-header: writes a header to the start of each log file serilog-sinks-file-gzip: compresses logs as they are written, using streaming GZIP compression serilog-sinks-file-archive: archives obsolete rolling log files before they are deleted by Serilog's retention mechanism Copyright © 2016 Serilog Contributors - Provided under the Apache License, Version 2.0."
  },
  "packages/System.Threading.Channels.8.0.0/PACKAGE.html": {
    "href": "packages/System.Threading.Channels.8.0.0/PACKAGE.html",
    "title": "| CoverageKiller2",
    "keywords": "About The System.Threading.Channels library provides types for passing data asynchronously between producers and consumers. Key Features Abstractions representing channels for one or more producers to publish data to one or more consumers APIs focused on asynchronous production and consumption of data Factory methods for producing multiple kinds of channels How to Use using System; using System.Threading.Channels; using System.Threading.Tasks; Channel<int> channel = Channel.CreateUnbounded<int>(); Task producer = Task.Run(async () => { int i = 0; while (true) { channel.Writer.TryWrite(i++); await Task.Delay(TimeSpan.FromSeconds(1)); } }); Task consumer = Task.Run(async () => { await foreach (int value in channel.Reader.ReadAllAsync()) { Console.WriteLine(value); } }); await Task.WhenAll(producer, consumer); Main Types The main types provided by this library are: System.Threading.Channel<T> System.Threading.Channel Additional Documentation Overview API documentation Related Packages https://www.nuget.org/packages/System.Threading.Tasks.Dataflow/ Feedback & Contributing System.Threading.Channels is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
  }
}